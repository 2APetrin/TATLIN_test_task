# TATLIN_test_task
Тестовое задание для TATLIN Data Services group симулирующее работу с магнитными лентами. В данном задании реализованы интерфейсы классов ленты и сортировщика лент, работающие с элементами типа int. Подробную формулировку задания см. в конце.

## Загрузка и сборка
```
git clone https://github.com/2APetrin/TATLIN_test_task.git
cd TATLIN_test_task
cmake -B build
cd build
make
```

## Использование
### Запуск консольного приложения
__Аргументы программы:__<br>
    1. По умолчанию принимает файл, в котором записаны int в виде символов char. Внутри программа приводит к бинарному виду.<br><br>
    2. Использование флага -bin позволяет подавать на вход файлы, в которых int записаны бинарно. Флаг должен стоять на первом, после объектного файла, месте. Т.е. перед именами входного и выходного файла.<br><br>
    3. Добавление в конце, после имен входного и выходного файлов, можно добавить имя конфигурационного файла. Если не добавлять, то используется файл config.txt, который лежит в директории проекта.<br>

__Возможные команды:__<br>
```
./tape_sort *in_int_file* *out_int_file*
./tape_sort *in_int_file* *out_int_file* *custom_config_file*

./tape_sort -bin *in_binary_file* *out_binary_file*
./tape_sort -bin *in_binary_file* *out_binary_file* *custom_config_file*
```

### Config файл
Конфигурационный файл, позволяющий менять настройки времени симуляции без перекомпиляции. Config файл должен иметь в себе 5 пар ключей и значений. Ключ и значение пишутся через пробел. Пример конфигурационного файла представлен ниже:
```
ram_size_byte 4
time_read     2
time_write    2
time_rewind   0.1
time_move     1
```
Если не хватает какого-то ключа или какое-то значение меньше нуля (для ram_size_byte меньше 4), то появится ошибка и указание проверить config файл.
| ключ | описание |
| --- | --- |
| ram_size_byte | длина оперативной памяти в *байтах* |
| time_read | время записи элемента в ячейку ленты |
| time_write | время чтения элемента из ячейки ленты |
| time_rewind | время, потраченное __на один элемент__ при перемотке |
| time_move | время сдвига на одну позицию |

## Требования
### Установлены:
* __CMake__ - минимальная версия - 3.8

* __Make__

* __GoogleTest__

## Описание интерфейсов классов

### template\<typename T\> class tape
Класс эмулирующий работу с магнитной лентой. Лента представлена в памяти как бинарный файл.

* __tape(std::string path)__ - открывает файл, а если такого нет, то кидает соответствующее исключение.

* __tape() = default__ - default конструктор. Необходимо последующее использование __open_tape()__
* __~tape() = default__ - default деструктор файла сам его закрывает
* __void move_next()__ - сдвигает пищущую головку на элемент вперед (двигает ленту назад)
* __void move_prev()__ - сдвигает пищущую головку на элемент назад
* __bool read_elem(T &elem)__ - считывает элементс текущей позиции ленты и кладет значени по ссылке. На попытку считать за пределами ленты кидает соответствующее исключение.
* __void write_elem(T elem)__ - записывает елемент на ленту. Если запись была осуществлена в конец, то размер ленты увеличивается.
* __void open_tape(std::string path)__ - открывает файл, а если такого нет, то создает файл с заданным именем. Все данные открываемого файла уничтожаются.
* __int rewind_begin()__ - перематывает ленту в начало, возвращает количество пройденных элементов.

* __template<typename TypeIt> int read_buffer(TypeIt beg, TypeIt end)__ - считывает элементы ленты пока не сравняются итераторы начала и конца контейнера или пока не встретится конец ленты. Взвращает количество считанных элементов.

* __template<typename TypeIt> int write_buffer(TypeIt beg, TypeIt end)__ - записывает элементы в ленту, пока не сравняются итераторы начала и конца контейнера.

* __int pos()__ - возвращает текущее положение пишущей головки.
* __int size() const__ - возвращает текущую длину ленты.
* __bool is_valid() const__ - проверяет состояние лены на валидность.
* __void dump()__ - выводит все содержимое ленты в консоль, если приложение скомпилировано с __-DTAPE_DUMP_MODE__. Не меняет положение указателя.

Запрещены:
* __tape(const tape&) = delete__ - copy constructor
* __tape(tape&&)      = delete__ - move constructor

* __tape& operator=(const tape&) = delete__ - copy assignment
* __tape& operator=(tape&&)      = delete__ - move assignment

##
### template\<typename T\> requires std::is_arithmetic_v\<T\> class sorting_machine
Класс, владеющий двумя вспомогательными лентами для произведения алгоритма сортировки. Оперативная память представлена вектором. Так же класс имеет объект таймер, который считает время симуляции сортировки.

* __sorting_machine(const machine_settings &settings)__ - создает файлы временных лент в директории temp. Для различности имен временных файлов использован pid процесса, в котором создается объект __sorting_machine__.

* __~sorting_machine()__ - удаляет временные файлы временных лент из temp директории.

* __void sort(tape<T> &in, tape<T> &out)__ - принимает входную и выходную ленты, сортирует данные с входной и записывает на выходную. Делает проверку на валидность лент и на совпадение, что входная и выходная ленты - одна и та же лента. При ошибке кидает исключение.

* __double time() const__ - показывает текущее значение таймера симуляции.

Запрещены:
* __sorting_machine(sorting_machine&)  = delete__ - copy constructor
* __sorting_machine(sorting_machine&&) = delete__ - move constructor

* __sorting_machine& operator=(const sorting_machine&) = delete__ - copy assignment
* __sorting_machine& operator=(sorting_machine&&) = delete__ - move assignment

## Тесты
Сделаны 2 вида тестов:
1. __end-to-end__ тесты
2. __unit__ тесты

Для запуска __end-to-end__ тестов надо запустить файл do_tests.sh из директории test. Эти тесты проверяют правильность работы общей задачи программы - сортировки. Для проверки ответов используется команда diff. Правильные ответы получены с помощью алгоритма сортировки стандартной библиотеки.

Для запуска unit тестов требуется запустить исполняемый файл unit_test из директории build. Unit тесты реализованы на GoogleTest.

## Алгоритм
Алгоритм - естественное (неймановское) слияние. Алгоритм требует наличия двух вспомогательных лент.

Входные данные разбиваются на сортированные подмассивы, которые поочередно кладутся то на первую, то на вторую вспомогательную ленту. Следующим шагом пары сортированных подмассивов со вспомогательных лент сливаются в выходную ленту. Так повторяется, пока на выходной ленте не окажется сортированная последовательность.

Данный подход позволяет не испольховать сортировку в оперативной памяти вовсе.

## Полная формулировка задания
Устройство хранения данных типа лента (Tape) предназначено для последовательной записи и
чтения данных. Считывающая/записывающая магнитная головка неподвижна во время чтения и
записи, а лента имеет возможность двигаться в обоих направлениях. Запись и чтение информации
возможны в ячейку ленты, на которой в данный момент находится магнитная головка.
Перемещения ленты – затратная по времени операция – лента не предназначена для
произвольного доступа.

Имеется входная лента длины N (где N – велико), содержащая элементы типа integer (232).
Имеется выходная лента такой же длины. Необходимо записать в выходную ленту
отсортированные по возрастанию элементы с входной ленты. Есть ограничение по использованию
оперативной памяти – не более M байт (M может быть < N, т.е. загрузить все данные с ленты в
оперативную память не получится). Для реализации алгоритма можно использовать разумное
количество временных лент, т.е. лент, на которых можно хранить какую-то временную
информацию, необходимую в процессе работы алгоритма.

Необходимо создать проект С++, компилируемый в консольное приложение, которое реализует
алгоритм сортировки данных с входной ленты на выходную. Необходимо сделать следующее:

* Определить интерфейс для работы с устройством типа лента.

* Написать класс, реализующий этот интерфейс и эмулирующий работу с лентой
посредством обычного файла. Должно быть возможно сконфигурировать (без
перекомпиляции – например, через внешний конфигурационный файл, который будет
прочитан на старте приложения) задержки по записи/чтению элемента с ленты, перемотки
ленты, и сдвига ленты на одну позицию.

* Файлы временных лент можно сохранять в директорию tmp.

* Написать класс, реализующий алгоритм сортировки данных с входной ленты на выходную.

* Консольное приложение должно принимать на вход имя входного и выходного файлов и
производить сортировку.

* Желательно написать юнит-тесты.